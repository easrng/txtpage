{
  "version": 3,
  "sources": ["../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js", "../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/micromark-util-character/index.js", "../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/micromark-util-encode/index.js", "../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/micromark-util-sanitize-uri/index.js", "../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/dioscuri/lib/compiler.js", "../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/dioscuri/lib/parser.js", "../tmp/esm-build-23820c9b970303496aa4739a417ff17e0b18ab98-50a63f31/node_modules/dioscuri/lib/buffer.js"],
  "sourceRoot": "/",
  "sourcesContent": ["// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nexport const unicodePunctuationRegex =\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n", "/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\n\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexport const asciiDigit = regexCheck(/\\d/)\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\nexport const unicodeWhitespace = regexCheck(/\\s/)\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nfunction regexCheck(regex) {\n  return check\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n", "const characterReferences = {'\"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt'}\n\n/**\n * Encode only the dangerous HTML characters.\n *\n * This ensures that certain characters which have special meaning in HTML are\n * dealt with.\n * Technically, we can skip `>` and `\"` in many cases, but CM includes them.\n *\n * @param {string} value\n * @returns {string}\n */\nexport function encode(value) {\n  return value.replace(/[\"&<>]/g, replace)\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function replace(value) {\n    // @ts-expect-error Hush, it\u2019s fine.\n    return '&' + characterReferences[value] + ';'\n  }\n}\n", "import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri` below).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * Then, a regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n * or `/^https?$/i` for `img[src]`.\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string|undefined} url\n * @param {RegExp} [protocol]\n * @returns {string}\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n\n  if (!protocol) {\n    return value\n  }\n\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, it\u2019s relative.\n    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it\u2019s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) || // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n/**\n * Normalize a URL (such as used in definitions).\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n * @returns {string}\n */\n\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n\n    let replace = '' // A correct percent encoded value.\n\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    } // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    } // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1) // A correct surrogate pair.\n\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      } // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    } // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n\n  return result.join('') + value.slice(start)\n}\n", "/**\n * @typedef {import('./parser.js').Token} Token\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {'\\r\\n'|'\\n'} [defaultLineEnding]\n *   Value to use for line endings not in `doc`.\n *\n *   Generally, discuri copies line endings (`'\\n'` or `'\\r\\n'`) in the\n *   document over to the compiled HTML.\n *   In some cases, such as `> a`, extra line endings are added:\n *   `<blockquote>\\n<p>a</p>\\n</blockquote>`.\n * @property {boolean} [allowDangerousProtocol=false]\n *   Whether to allow potentially dangerous protocols in URLs.\n *\n *   URLs relative to the current protocol are always allowed\n *   (such as, `image.jpg`).\n *   Otherwise, the allowed protocols are `gemini`, `http`, `https`, `irc`,\n *   `ircs`, `mailto`, and `xmpp`.\n */\n\nimport {sanitizeUri} from 'micromark-util-sanitize-uri'\nimport {encode} from 'micromark-util-encode'\n\n/**\n * Create a compile function.\n *\n * @param {Options} [options]\n */\nexport function compiler(options) {\n  const settings = options || {}\n  let defaultLineEnding = settings.defaultLineEnding\n  const allowDangerousProtocol = settings.allowDangerousProtocol\n  /** @type {string|undefined} */\n  let atEol\n  /** @type {boolean|undefined} */\n  let slurpEol\n  /** @type {string|boolean} */\n  let preformatted\n  /** @type {boolean|undefined} */\n  let inList\n\n  return compile\n\n  /**\n   * Create a compile function.\n   *\n   * @param {Array<Token>} tokens\n   * @returns {string}\n   */\n  // eslint-disable-next-line complexity\n  function compile(tokens) {\n    /** @type {Array<string>} */\n    const results = []\n    let index = -1\n\n    // Infer an EOL if none was defined.\n    if (!defaultLineEnding) {\n      while (++index < tokens.length) {\n        if (tokens[index].type === 'eol') {\n          // @ts-expect-error Correctly parsed.\n          defaultLineEnding = tokens[index].value\n          break\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < tokens.length) {\n      const token = tokens[index]\n\n      if (\n        inList &&\n        ((token.type === 'eol' && token.hard) ||\n          (token.type !== 'eol' &&\n            token.type !== 'listSequence' &&\n            token.type !== 'listText' &&\n            token.type !== 'whitespace'))\n      ) {\n        // If an `atEol` is still set, we haven\u2019t seen an EOL yet, so add one.\n        if (atEol) results.push(atEol, defaultLineEnding || '\\n')\n        results.push('</ul>')\n        // If an EOL was seen, then we have more content.\n        // Also note that in that case `defaultLineEnding` is set.\n        if (!atEol && defaultLineEnding) results.push(defaultLineEnding)\n        inList = undefined\n        atEol = undefined\n      }\n\n      if (token.type === 'eol') {\n        if (atEol) results.push(atEol)\n        if (token.hard) results.push('<br />')\n        if (!slurpEol) results.push(encode(token.value))\n        atEol = undefined\n        slurpEol = undefined\n      } else if (token.type === 'eof') {\n        if (atEol) results.push(atEol)\n        if (preformatted === 'preAlt') results.push('</code>')\n        if (preformatted) results.push('</pre>')\n      } else if (token.type === 'quoteSequence') {\n        results.push('<blockquote>')\n        atEol = '</blockquote>'\n      } else if (token.type === 'linkSequence') {\n        results.push('<div><a href=\"')\n        atEol = '\"></a></div>' // Set this for when there\u2019s no `linkUrl`.\n      } else if (token.type === 'linkUrl') {\n        results.push(\n          sanitizeUri(\n            token.value,\n            allowDangerousProtocol\n              ? undefined\n              : /^(gemini|https?|ircs?|mailto|xmpp)$/i\n          ),\n          '\">'\n        )\n        atEol = '</a></div>'\n      } else if (token.type === 'listSequence') {\n        if (!inList) {\n          results.push('<ul>', defaultLineEnding || '\\n')\n          inList = true\n        }\n\n        results.push('<li>')\n        atEol = '</li>'\n      } else if (token.type === 'headingSequence') {\n        results.push('<h', String(token.value.length), '>')\n        atEol = '</h' + token.value.length + '>'\n      } else if (token.type === 'preSequence') {\n        results.push(\n          preformatted === 'preAlt' ? '</code>' : '',\n          '<',\n          preformatted ? '/' : '',\n          'pre>'\n        )\n        preformatted = !preformatted\n        if (preformatted) slurpEol = true\n      } else if (token.type === 'preAlt') {\n        if (preformatted) {\n          results.push('<code class=\"language-', encode(token.value), '\">')\n          preformatted = 'preAlt'\n        }\n      } else if (\n        token.type === 'headingText' ||\n        token.type === 'linkText' ||\n        token.type === 'listText' ||\n        token.type === 'preText'\n      ) {\n        results.push(encode(token.value))\n      } else if (token.type === 'quoteText') {\n        results.push(\n          defaultLineEnding || '\\n',\n          '<p>',\n          token.value,\n          '</p>',\n          defaultLineEnding || '\\n'\n        )\n      } else if (token.type === 'text') {\n        results.push('<p>', encode(token.value), '</p>')\n      }\n      // Else would be `whitespace`.\n    }\n\n    return results.join('')\n  }\n}\n", "/**\n * @typedef {import('unist').Point} Point\n *\n * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'latin1'|'binary'|'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *   This is a copy of the typing from Node, copied to prevent Node globals\n *   from being needed.\n *   Copied from\n *   <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a2bc1d8/types/node/globals.d.ts#L174>.\n *\n * @typedef {string|Buffer} Buf\n *   Acceptable input.\n *\n * @typedef {'whitespace'|'eof'|'eol'|'preSequence'|'preAlt'|'preText'|'headingSequence'|'headingText'|'listSequence'|'listText'|'linkSequence'|'linkUrl'|'linkText'|'quoteSequence'|'quoteText'|'text'} Type\n *   Token type.\n *\n * @typedef Token\n *   Base token.\n * @property {Type} type\n *   Token type.\n * @property {string} value\n *   Token value.\n * @property {boolean|undefined} [hard]\n *   Whether this token was hard (used on `eol` tokens).\n * @property {Point} start\n *   Starting point.\n * @property {Point} end\n *   Ending point.\n */\n\n/**\n * @returns {(value: Buf|undefined, encoding?: BufferEncoding|undefined, end?: boolean|undefined) => Array<Token>}\n */\nexport function parser() {\n  /** @type {Array<string>} Chunks. */\n  const values = []\n  let line = 1\n  let column = 1\n  let offset = 0\n  /** @type {boolean} Whether we\u2019re currently in preformatted. */\n  let preformatted\n\n  return parse\n\n  /**\n   * Parse a chunk.\n   *\n   * @param {Buf|undefined} buf\n   * @param {BufferEncoding|undefined} [encoding]\n   * @param {boolean|undefined} [done=false]\n   * @returns {Array<Token>}\n   */\n  function parse(buf, encoding, done) {\n    let end = buf ? buf.indexOf('\\n') : -1\n    let start = 0\n    /** @type {Array<Token>} */\n    const results = []\n\n    while (end > -1) {\n      // @ts-expect-error: `buf` is defined if we\u2019re here.\n      let value = values.join('') + buf.slice(start, end).toString(encoding)\n      /** @type {string} */\n      let eol\n\n      // Drop values.\n      values.length = 0\n\n      if (value.charCodeAt(value.length - 1) === 13 /* `\\r` */) {\n        value = value.slice(0, -1)\n        eol = '\\r\\n'\n      } else {\n        eol = '\\n'\n      }\n\n      parseLine(value)\n      add('eol', eol, {hard: !preformatted && value.length === 0})\n\n      start = end + 1\n      // @ts-expect-error: `buf` is defined if we\u2019re here.\n      end = buf.indexOf('\\n', start)\n    }\n\n    if (buf) values.push(buf.slice(start).toString(encoding))\n\n    if (done) {\n      parseLine(values.join(''))\n      add('eof', '')\n    }\n\n    return results\n\n    /**\n     * Parse a single line.\n     *\n     * @param {string} value\n     */\n    // eslint-disable-next-line complexity\n    function parseLine(value) {\n      const code = value.charCodeAt(0)\n\n      if (\n        code === 96 /* `` ` `` */ &&\n        value.charCodeAt(1) === 96 /* `` ` `` */ &&\n        value.charCodeAt(2) === 96 /* `` ` `` */\n      ) {\n        add('preSequence', value.slice(0, 3))\n        if (value.length !== 3) add('preAlt', value.slice(3))\n        preformatted = !preformatted\n      }\n      // Pre text.\n      else if (preformatted) {\n        if (value) add('preText', value)\n      }\n      // Heading.\n      else if (code === 35 /* `#` */) {\n        let index = 1\n        while (index < 3 && value.charCodeAt(index) === 35 /* `#` */) index++\n        add('headingSequence', value.slice(0, index))\n\n        // Optional whitespace.\n        const start = index\n        while (ws(value.charCodeAt(index))) index++\n        if (start !== index) add('whitespace', value.slice(start, index))\n\n        // Optional heading text.\n        if (index !== value.length) add('headingText', value.slice(index))\n      }\n      // List.\n      else if (\n        code === 42 /* `*` */ &&\n        (value.length === 1 || ws(value.charCodeAt(1)))\n      ) {\n        add('listSequence', '*')\n\n        // Optional whitespace.\n        let index = 1\n        while (ws(value.charCodeAt(index))) index++\n        if (index > 1) add('whitespace', value.slice(1, index))\n\n        // Optional list text.\n        if (value.length > index) add('listText', value.slice(index))\n      }\n      // Link\n      else if (code === 61 /* `=` */ && value.charCodeAt(1) === 62 /* `>` */) {\n        add('linkSequence', value.slice(0, 2))\n\n        // Optional whitespace.\n        let index = 2\n        while (ws(value.charCodeAt(index))) index++\n        if (index > 2) add('whitespace', value.slice(2, index))\n\n        // Optional non-whitespace is the URL.\n        let start = index\n        while (index < value.length && !ws(value.charCodeAt(index))) index++\n        if (index > start) add('linkUrl', value.slice(start, index))\n\n        // Optional whitespace.\n        start = index\n        while (ws(value.charCodeAt(index))) index++\n        if (index > start) add('whitespace', value.slice(start, index))\n\n        // Rest is optional link text.\n        if (value.length > index) add('linkText', value.slice(index))\n      }\n      // Block quote.\n      else if (code === 62 /* `>` */) {\n        add('quoteSequence', value.slice(0, 1))\n\n        // Optional whitespace.\n        let index = 1\n        while (ws(value.charCodeAt(index))) index++\n        if (index > 1) add('whitespace', value.slice(1, index))\n\n        if (value.length > index) add('quoteText', value.slice(index))\n      }\n      // Text.\n      else if (value.length > 0) {\n        add('text', value)\n      }\n    }\n\n    /**\n     * Add a token.\n     *\n     * @param {Type} type\n     * @param {string} value\n     * @param {Record<string, unknown>} [fields]\n     */\n    function add(type, value, fields) {\n      const start = now()\n      const token = {}\n\n      offset += value.length\n      column += value.length\n\n      // Note that only a final line feed is supported: it\u2019s assumed that\n      // they\u2019ve been split over separate tokens already.\n      if (value.charCodeAt(value.length - 1) === 10 /* `\\n` */) {\n        line++\n        column = 1\n      }\n\n      token.type = type\n      token.value = value\n      if (fields) Object.assign(token, fields)\n      token.start = start\n      token.end = now()\n      results.push(token)\n    }\n\n    /**\n     * Get the current point.\n     *\n     * @returns {Point}\n     */\n    function now() {\n      return {line, column, offset}\n    }\n  }\n}\n\n/**\n * Check whether a character code is whitespace\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction ws(code) {\n  return code === 9 /* `\\t` */ || code === 32 /* ` ` */\n}\n", "/**\n * @typedef {import('./parser.js').Buf} Buf\n * @typedef {import('./parser.js').BufferEncoding} BufferEncoding\n * @typedef {import('./compiler.js').Options} Options\n */\n\nimport {compiler} from './compiler.js'\nimport {parser} from './parser.js'\n\n/**\n * Compile gemtext to HTML.\n *\n * @param {Buf} doc\n *   Gemtext to parse\n * @param {BufferEncoding} [encoding]\n *   Character encoding to understand `doc` as when it\u2019s a `Buffer`.\n * @param {Options} [options]\n *   Compile configuration (optional).\n */\nexport function buffer(doc, encoding, options) {\n  return compiler(options)(parser()(doc, encoding, true))\n}\n"],
  "mappings": "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",
  "names": ["value", "start"]
}
