/*
(The MIT License)

Copyright (c) 2021 Titus Wormer <tituswormer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

let c={"0":["// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nexport const unicodePunctuationRegex =\n/[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;"],"1":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { unicodePunctuationRegex } from /*\"./lib/unicode-punctuation-regex.js?module\"*/",{"m":0},";\n/**\n                                                                                      * Check whether the character code represents an ASCII alpha (`a` through `z`,\n                                                                                      * case insensitive).\n                                                                                      *\n                                                                                      * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n                                                                                      *\n                                                                                      * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n                                                                                      * to U+005A (`Z`).\n                                                                                      *\n                                                                                      * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n                                                                                      * to U+007A (`z`).\n                                                                                      */\n\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n/**\n                                                   * Check whether the character code represents an ASCII digit (`0` through `9`).\n                                                   *\n                                                   * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n                                                   * U+0039 (`9`).\n                                                   */\n\nexport const asciiDigit = regexCheck(/\\d/);\n/**\n                                             * Check whether the character code represents an ASCII hex digit (`a` through\n                                             * `f`, case insensitive, or `0` through `9`).\n                                             *\n                                             * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n                                             * digit, or an ASCII lower hex digit.\n                                             *\n                                             * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n                                             * (`A`) to U+0046 (`F`).\n                                             *\n                                             * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n                                             * (`a`) to U+0066 (`f`).\n                                             */\n\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n/**\n                                                        * Check whether the character code represents an ASCII alphanumeric (`a`\n                                                        * through `z`, case insensitive, or `0` through `9`).\n                                                        *\n                                                        * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n                                                        * (see `asciiAlpha`).\n                                                        */\n\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n/**\n                                                            * Check whether the character code represents ASCII punctuation.\n                                                            *\n                                                            * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n                                                            * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n                                                            * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n                                                            * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n                                                            */\n\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n/**\n                                                               * Check whether the character code represents an ASCII atext.\n                                                               *\n                                                               * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n                                                               * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n                                                               * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n                                                               * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n                                                               * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n                                                               * (`{`) to U+007E TILDE (`~`).\n                                                               *\n                                                               * See:\n                                                               * **\\[RFC5322]**:\n                                                               * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n                                                               * P. Resnick.\n                                                               * IETF.\n                                                               */\n\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n/**\n                                                              * Check whether a character code is an ASCII control character.\n                                                              *\n                                                              * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n                                                              * to U+001F (US), or U+007F (DEL).\n                                                              *\n                                                              * @param {Code} code\n                                                              * @returns {code is number}\n                                                              */\n\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127));\n\n}\n/**\n   * Check whether a character code is a markdown line ending (see\n   * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n   *\n   * @param {Code} code\n   * @returns {code is number}\n   */\n\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n/**\n   * Check whether a character code is a markdown line ending.\n   *\n   * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n   * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n   *\n   * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n   * RETURN (CR) are replaced by these virtual characters depending on whether\n   * they occurred together.\n   *\n   * @param {Code} code\n   * @returns {code is number}\n   */\n\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n/**\n   * Check whether a character code is a markdown space.\n   *\n   * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n   * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n   *\n   * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n   * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n   * SPACE (VS) characters, depending on the column at which the tab occurred.\n   *\n   * @param {Code} code\n   * @returns {code is number}\n   */\n\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n/**\n   * Check whether the character code represents Unicode whitespace.\n   *\n   * Note that this does handle micromark specific markdown whitespace characters.\n   * See `markdownLineEndingOrSpace` to check that.\n   *\n   * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n   * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n   * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n   *\n   * See:\n   * **\\[UNICODE]**:\n   * [The Unicode Standard](https://www.unicode.org/versions/).\n   * Unicode Consortium.\n   */\n\nexport const unicodeWhitespace = regexCheck(/\\s/);\n/**\n                                                    * Check whether the character code represents Unicode punctuation.\n                                                    *\n                                                    * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n                                                    * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n                                                    * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n                                                    * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n                                                    * punctuation (see `asciiPunctuation`).\n                                                    *\n                                                    * See:\n                                                    * **\\[UNICODE]**:\n                                                    * [The Unicode Standard](https://www.unicode.org/versions/).\n                                                    * Unicode Consortium.\n                                                    */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex);\n/**\n                                                                        * Create a code check from a regex.\n                                                                        *\n                                                                        * @param {RegExp} regex\n                                                                        * @returns {(code: Code) => code is number}\n                                                                        */\n\nfunction regexCheck(regex) {\n  return check;\n  /**\n                 * Check whether a code matches the bound regex.\n                 *\n                 * @param {Code} code Character code\n                 * @returns {code is number} Whether the character code matches the bound regex\n                 */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code));\n  }\n}"],"2":["const characterReferences = { '\"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt'\n\n  /**\n                                                                             * Encode only the dangerous HTML characters.\n                                                                             *\n                                                                             * This ensures that certain characters which have special meaning in HTML are\n                                                                             * dealt with.\n                                                                             * Technically, we can skip `>` and `\"` in many cases, but CM includes them.\n                                                                             *\n                                                                             * @param {string} value\n                                                                             * @returns {string}\n                                                                             */ };\nexport function encode(value) {\n  return value.replace(/[\"&<>]/g, replace);\n\n  /**\n                                             * @param {string} value\n                                             * @returns {string}\n                                             */\n  function replace(value) {\n    // @ts-expect-error Hush, it’s fine.\n    return '&' + characterReferences[value] + ';';\n  }\n}"],"3":["import { asciiAlphanumeric } from /*\"https://unpkg.com/micromark-util-character@^1.0.0?module\"*/",{"m":1},";\nimport { encode } from /*\"https://unpkg.com/micromark-util-encode@^1.0.0?module\"*/",{"m":2},";\n\n/**\n                                                                                 * Make a value safe for injection as a URL.\n                                                                                 *\n                                                                                 * This encodes unsafe characters with percent-encoding and skips already\n                                                                                 * encoded sequences (see `normalizeUri` below).\n                                                                                 * Further unsafe characters are encoded as character references (see\n                                                                                 * `micromark-util-encode`).\n                                                                                 *\n                                                                                 * Then, a regex of allowed protocols can be given, in which case the URL is\n                                                                                 * sanitized.\n                                                                                 * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`,\n                                                                                 * or `/^https?$/i` for `img[src]`.\n                                                                                 * If the URL includes an unknown protocol (one not matched by `protocol`, such\n                                                                                 * as a dangerous example, `javascript:`), the value is ignored.\n                                                                                 *\n                                                                                 * @param {string|undefined} url\n                                                                                 * @param {RegExp} [protocol]\n                                                                                 * @returns {string}\n                                                                                 */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''));\n\n  if (!protocol) {\n    return value;\n  }\n\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n\n  if (\n  // If there is no protocol, it’s relative.\n  colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n  slash > -1 && colon > slash ||\n  questionMark > -1 && colon > questionMark ||\n  numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon)))\n  {\n    return value;\n  }\n\n  return '';\n}\n/**\n   * Normalize a URL (such as used in definitions).\n   *\n   * Encode unsafe characters with percent-encoding, skipping already encoded\n   * sequences.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n\nfunction normalizeUri(value) {\n  /** @type {string[]} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n\n    let replace = ''; // A correct percent encoded value.\n\n    if (\n    code === 37 &&\n    asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n    asciiAlphanumeric(value.charCodeAt(index + 2)))\n    {\n      skip = 2;\n    } // ASCII.\n    else if (code < 128) {\n        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n          replace = String.fromCharCode(code);\n        }\n      } // Astral.\n      else if (code > 55295 && code < 57344) {\n          const next = value.charCodeAt(index + 1); // A correct surrogate pair.\n\n          if (code < 56320 && next > 56319 && next < 57344) {\n            replace = String.fromCharCode(code, next);\n            skip = 1;\n          } // Lone surrogate.\n          else {\n              replace = '\\uFFFD';\n            }\n        } // Unicode.\n        else {\n            replace = String.fromCharCode(code);\n          }\n\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n\n  return result.join('') + value.slice(start);\n}"],"4":["import { sanitizeUri } from /*\"https://unpkg.com/micromark-util-sanitize-uri@^1.0.0?module\"*/",{"m":3},";\n// @ts-expect-error: published w/o types, apparently.\nimport { encode } from /*\"https://unpkg.com/micromark-util-encode@^1.0.0?module\"*/",{"m":2},";\n\n/**\n                                                                                 * Configuration.\n                                                                                 *\n                                                                                 * @typedef Options\n                                                                                 * @property {'\\r\\n'|'\\n'} [defaultLineEnding]\n                                                                                 * @property {boolean} [allowDangerousProtocol=false]\n                                                                                 */\n\n/**\n                                                                                     * Create a compile function.\n                                                                                     *\n                                                                                     * @param {Options} [options]\n                                                                                     */\nexport function compiler(options) {\n  const settings = options || {};\n  let defaultLineEnding = settings.defaultLineEnding;\n  const allowDangerousProtocol = settings.allowDangerousProtocol;\n  /** @type {string|undefined} */\n  let atEol;\n  /** @type {boolean|undefined} */\n  let slurpEol;\n  /** @type {string|boolean} */\n  let preformatted;\n  /** @type {boolean|undefined} */\n  let inList;\n\n  return compile;\n\n  /**\n                   * Create a compile function.\n                   *\n                   * @param {import('./parser.js').Token[]} tokens\n                   * @returns {string}\n                   */\n  // eslint-disable-next-line complexity\n  function compile(tokens) {\n    let index = -1;\n    /** @type {string[]} */\n    const results = [];\n    /** @type {import('./parser.js').Token} */\n    let token;\n\n    // Infer an EOL if none was defined.\n    if (!defaultLineEnding) {\n      while (++index < tokens.length) {\n        if (tokens[index].type === 'eol') {\n          // @ts-expect-error Correctly parsed.\n          defaultLineEnding = tokens[index].value;\n          break;\n        }\n      }\n\n      index = -1;\n    }\n\n    while (++index < tokens.length) {\n      token = tokens[index];\n\n      if (\n      inList && (\n      token.type === 'eol' && token.hard ||\n      token.type !== 'eol' &&\n      token.type !== 'listSequence' &&\n      token.type !== 'listText' &&\n      token.type !== 'whitespace'))\n      {\n        // If an `atEol` is still set, we haven’t seen an EOL yet, so add one.\n        if (atEol) results.push(atEol, defaultLineEnding || '\\n');\n        results.push('</ul>');\n        // If an EOL was seen, then we have more content.\n        // Also note that in that case `defaultLineEnding` is set.\n        if (!atEol && defaultLineEnding) results.push(defaultLineEnding);\n        inList = undefined;\n        atEol = undefined;\n      }\n\n      if (token.type === 'eol') {\n        if (atEol) results.push(atEol);\n        if (token.hard) results.push('<br />');\n        if (!slurpEol) results.push(encode(token.value));\n        atEol = undefined;\n        slurpEol = undefined;\n      } else if (token.type === 'eof') {\n        if (atEol) results.push(atEol);\n        if (preformatted === 'preAlt') results.push('</code>');\n        if (preformatted) results.push('</pre>');\n      } else if (token.type === 'quoteSequence') {\n        results.push('<blockquote>');\n        atEol = '</blockquote>';\n      } else if (token.type === 'linkSequence') {\n        results.push('<div><a href=\"');\n        atEol = '\"></a></div>'; // Set this for when there’s no `linkUrl`.\n      } else if (token.type === 'linkUrl') {\n        results.push(\n        sanitizeUri(\n        token.value,\n        allowDangerousProtocol ?\n        undefined :\n        /^(gemini|https?|ircs?|mailto|xmpp)$/i),\n\n        '\">');\n\n        atEol = '</a></div>';\n      } else if (token.type === 'listSequence') {\n        if (!inList) {\n          results.push('<ul>', defaultLineEnding || '\\n');\n          inList = true;\n        }\n\n        results.push('<li>');\n        atEol = '</li>';\n      } else if (token.type === 'headingSequence') {\n        results.push('<h', String(token.value.length), '>');\n        atEol = '</h' + token.value.length + '>';\n      } else if (token.type === 'preSequence') {\n        results.push(\n        preformatted === 'preAlt' ? '</code>' : '',\n        '<',\n        preformatted ? '/' : '',\n        'pre>');\n\n        preformatted = !preformatted;\n        if (preformatted) slurpEol = true;\n      } else if (token.type === 'preAlt') {\n        if (preformatted) {\n          results.push('<code class=\"language-', encode(token.value), '\">');\n          preformatted = 'preAlt';\n        }\n      } else if (\n      token.type === 'headingText' ||\n      token.type === 'linkText' ||\n      token.type === 'listText' ||\n      token.type === 'preText')\n      {\n        results.push(encode(token.value));\n      } else if (token.type === 'quoteText') {\n        results.push(\n        defaultLineEnding || '\\n',\n        '<p>',\n        token.value,\n        '</p>',\n        defaultLineEnding || '\\n');\n\n      } else if (token.type === 'text') {\n        results.push('<p>', encode(token.value), '</p>');\n      }\n      // Else would be `whitespace`.\n    }\n\n    return results.join('');\n  }\n}"],"5":["/**\n * Encodings supported by the buffer class\n * This is a copy of the typing from Node, copied to prevent Node globals from being needed.\n * Copied from <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a2bc1d8/types/node/globals.d.ts#L174>\n *\n * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'latin1'|'binary'|'hex'} BufferEncoding\n */\n\n/**\n     * Acceptable input.\n     *\n     * @typedef {string|Buffer} Buf\n     */\n\n/**\n         * @typedef {'whitespace'|'eof'|'eol'|'preSequence'|'preAlt'|'preText'|'headingSequence'|'headingText'|'listSequence'|'listText'|'linkSequence'|'linkUrl'|'linkText'|'quoteSequence'|'quoteText'|'text'} Type\n         */\n\n/**\n             * Single point.\n             *\n             * @typedef Point\n             * @property {number} line\n             * @property {number} column\n             * @property {number} offset\n             */\n\n/**\n                 * Base token.\n                 *\n                 * @typedef Token\n                 * @property {Type} type\n                 * @property {string} value\n                 * @property {boolean} [hard]\n                 * @property {Point} start\n                 * @property {Point} end\n                 */\n\n/**\n                     * @returns {(value: Buf|undefined, encoding?: BufferEncoding|undefined, end?: boolean|undefined) => Token[]}\n                     */\nexport function parser() {\n  /** @type {string[]} Chunks. */\n  const values = [];\n  let line = 1;\n  let column = 1;\n  let offset = 0;\n  /** @type {boolean} Whether we’re currently in preformatted. */\n  let preformatted;\n\n  return parse;\n\n  /**\n                 * Parse a chunk.\n                 *\n                 * @param {Buf|undefined} buf\n                 * @param {BufferEncoding|undefined} [encoding]\n                 * @param {boolean|undefined} [done=false]\n                 * @returns {Token[]}\n                 */\n  function parse(buf, encoding, done) {\n    let end = buf ? buf.indexOf('\\n') : -1;\n    let start = 0;\n    /** @type {Token[]} */\n    const results = [];\n\n    while (end > -1) {\n      // @ts-expect-error: `buf` is defined if we’re here.\n      let value = values.join('') + buf.slice(start, end).toString(encoding);\n      /** @type {string} */\n      let eol;\n\n      values.length = 0;\n\n      if (value.charCodeAt(value.length - 1) === 13 /* `\\r` */) {\n          value = value.slice(0, -1);\n          eol = '\\r\\n';\n        } else {\n        eol = '\\n';\n      }\n\n      parseLine(value);\n      add('eol', eol, { hard: !preformatted && value.length === 0 });\n\n      start = end + 1;\n      // @ts-expect-error: `buf` is defined if we’re here.\n      end = buf.indexOf('\\n', start);\n    }\n\n    if (buf) values.push(buf.slice(start).toString(encoding));\n\n    if (done) {\n      parseLine(values.join(''));\n      add('eof', '');\n    }\n\n    return results;\n\n    /**\n                     * Parse a single line.\n                     *\n                     * @param {string} value\n                     */\n    // eslint-disable-next-line complexity\n    function parseLine(value) {\n      const code = value.charCodeAt(0);\n\n      if (\n      code === 96 /* `` ` `` */ &&\n      value.charCodeAt(1) === 96 /* `` ` `` */ &&\n      value.charCodeAt(2) === 96 /* `` ` `` */)\n        {\n          add('preSequence', value.slice(0, 3));\n          if (value.length !== 3) add('preAlt', value.slice(3));\n          preformatted = !preformatted;\n        }\n        // Pre text.\n      else if (preformatted) {\n          if (value) add('preText', value);\n        }\n        // Heading.\n        else if (code === 35 /* `#` */) {\n              let index = 1;\n              while (index < 3 && value.charCodeAt(index) === 35 /* `#` */) index++;\n              add('headingSequence', value.slice(0, index));\n\n              // Optional whitespace.\n              const start = index;\n              while (ws(value.charCodeAt(index))) index++;\n              if (start !== index) add('whitespace', value.slice(start, index));\n\n              // Optional heading text.\n              if (index !== value.length) add('headingText', value.slice(index));\n            }\n            // List.\n          else if (\n            code === 42 /* `*` */ && (\n            value.length === 1 || ws(value.charCodeAt(1))))\n            {\n              add('listSequence', '*');\n\n              // Optional whitespace.\n              let index = 1;\n              while (ws(value.charCodeAt(index))) index++;\n              if (index > 1) add('whitespace', value.slice(1, index));\n\n              // Optional list text.\n              if (value.length > index) add('listText', value.slice(index));\n            }\n            // Link\n            else if (code === 61 /* `=` */ && value.charCodeAt(1) === 62 /* `>` */) {\n                  add('linkSequence', value.slice(0, 2));\n\n                  // Optional whitespace.\n                  let index = 2;\n                  while (ws(value.charCodeAt(index))) index++;\n                  if (index > 2) add('whitespace', value.slice(2, index));\n\n                  // Optional non-whitespace is the URL.\n                  let start = index;\n                  while (index < value.length && !ws(value.charCodeAt(index))) index++;\n                  if (index > start) add('linkUrl', value.slice(start, index));\n\n                  // Optional whitespace.\n                  start = index;\n                  while (ws(value.charCodeAt(index))) index++;\n                  if (index > start) add('whitespace', value.slice(start, index));\n\n                  // Rest is optional link text.\n                  if (value.length > index) add('linkText', value.slice(index));\n                }\n                // Block quote.\n              else if (code === 62 /* `>` */) {\n                    add('quoteSequence', value.slice(0, 1));\n\n                    // Optional whitespace.\n                    let index = 1;\n                    while (ws(value.charCodeAt(index))) index++;\n                    if (index > 1) add('whitespace', value.slice(1, index));\n\n                    if (value.length > index) add('quoteText', value.slice(index));\n                  }\n                  // Text.\n                else if (value.length > 0) {\n                    add('text', value);\n                  }\n    }\n\n    /**\n       * Add a token.\n       *\n       * @param {Type} type\n       * @param {string} value\n       * @param {Record.<string, unknown>} [fields]\n       */\n    function add(type, value, fields) {\n      const start = now();\n      const token = {};\n\n      offset += value.length;\n      column += value.length;\n\n      // Note that only a final line feed is supported: it’s assumed that\n      // they’ve been split over separate tokens already.\n      if (value.charCodeAt(value.length - 1) === 10 /* `\\n` */) {\n          line++;\n          column = 1;\n        }\n\n      token.type = type;\n      token.value = value;\n      if (fields) Object.assign(token, fields);\n      token.start = start;\n      token.end = now();\n      results.push(token);\n    }\n\n    /**\n       * Get the current point.\n       *\n       * @returns {Point}\n       */\n    function now() {\n      return { line, column, offset };\n    }\n  }\n}\n\n/**\n   * Check whether a character code is whitespace\n   *\n   * @param {number} code\n   * @returns {boolean}\n   */\nfunction ws(code) {\n  return code === 9 /* `\\t` */ || code === 32; /* ` ` */\n}"],"6":["import { compiler } from /*\"./compiler.js?module\"*/",{"m":4},";\nimport { parser } from /*\"./parser.js?module\"*/",{"m":5},";\n\n/**\n                                              * @param {import('./parser.js').Buf} buf\n                                              * @param {import('./parser.js').BufferEncoding} [encoding]\n                                              * @param {import('./compiler.js').Options} [options]\n                                              */\nexport function buffer(buf, encoding, options, handle=e=>e) {\n  return compiler(options)(handle(parser()(buf, encoding, true)));\n}"]},f=6,u=(c,f)=>URL.createObjectURL(new Blob(c[f].map(e=>typeof e=="object"?JSON.stringify(u(c,e.m)):e),{type:"text/javascript"})),m=import(u(c,f));export default m
